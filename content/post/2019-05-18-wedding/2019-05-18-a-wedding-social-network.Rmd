---
title: A wedding social network
author: ~
date: '2019-05-18'
slug: a-wedding-social-network
categories: []
tags: []
image:
  caption: ''
  focal_point: ''
---

Wedding season will soon be in full swing. During cocktail hour or over the salad course at dinner, a common question that guests ask one another is how they know the happy couple. The answers that come up  are localized to *particular individuals*, which means it's difficult to get a big picture understanding of how *entire groups of people* converge to celebrate the start of a marriage.

Thinking about this shortly before our own wedding last April, my then-fiancee (now wife :heart_eyes:) and I conducted a social network analysis of the guests who would celebrate with us on our special day. So we gathered a list of our 134 guests and placed their names down column A and across row 1 of an Excel spreadsheet, creating a 134 x 134 adjacency matrix. Each entry in the matrix represents if two guests had previously met in any capacity (0 = no, 1 = yes). It took us a couple hours spread over a few days to fill in the matrix, but we ended up with the following. Guests' names are row and column labels. White squares mean the two guests hadn't met and black  squares mean they had met. Every square along the diagonal is black since guests have of course met themselves.

```{r include = FALSE}
# packages needed
if (!require("tidyverse")) {install.packages("tidyverse")}; require("tidyverse")
if (!require("corrplot")) {install.packages("corrplot")}; require("corrplot")

# load data
read_csv(file = "subjective.network.csv") -> admat_lower # adjacency matrix, lower half only

# convert to matrix
admat_lower %>%
  select(2:ncol(admat_lower)) %>%
  as.matrix() -> admat_lower

# create full adjacency matrix
  # 134 x 134 identity matrix
admat_full <- diag(nrow(admat_lower))

  # add column and row labels, first names only
word(string = colnames(admat_lower), start = 1, sep = " ") -> colnames(admat_full) -> rownames(admat_full)

  # make lower half admat_full the same as lower half of admat_lower
admat_full[lower.tri(admat_full)] <- admat_lower[lower.tri(admat_lower)]

  # reflect lower half to upper half
admat_full + t(admat_full) -> admat_full

  # make diag equal to 1
diag(admat_full) <- 1

  # check if symmetric
isSymmetric(admat_full)
```

```{r echo = FALSE}

corrplot::corrplot(corr = admat_full, 
                   method = "square", 
                   type = "full",
                   diag = TRUE,
                   order = "FPC",
                   tl.cex = 0.4,
                   tl.col = "black",
                   cl.pos = "n",
                   col = colorRampPalette(c("green","white","black"))(200))
```



